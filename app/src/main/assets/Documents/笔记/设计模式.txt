设计模式

第一章 设计模式的划分
第二章 创建型设计模式：五种
第三章 行为型设计模式：十一种，掌握六种
第四章 结构型设计模式：七种，掌握六种

第一章 设计模式的划分
01.面向对象的六大原则
1）单一职责原则(Single Responsibility Principle)：重要
一个类只负责一项职责；

2）开闭原则（Open Close Principle）：重要
对扩展开放，对修改关闭；
让程序更稳定，更灵活；依赖于抽象，独立于实现。在文件来说就是隐藏实现private，暴露调用方法public。

3）里氏代换原则（Liskov Substitution Principle）：
子类可以扩展父类的功能，但不要改变父类原有的功能。
构建扩展性更好的系统；核心依然依赖于抽象，拆分出共同的实现方法，单独编写不同的实现，依赖于面向对象三大特性中的继承与多态。

4）依赖倒转原则（Dependence Inversion Principle）：重要
面向接口编程；
让项目拥有变化的能力；模块间的依赖通过抽象发生，实现类之间不发生直接依赖关系，依赖于三大特性中的多态。

5）接口隔离原则（Interface Segregation Principle）：
设计接口功能尽量细化；最小功能单元。
系统拥有更高的灵活性；接口中方法的拆分，实现类只需要继承自己需要的接口

6）迪米特法则（最少知道原则）（Demeter Principle）：
降低耦合，局部变量中不要引入新的类。？？局部的话，内存回收不是更快吗？
更好的扩展性；类似于MVP，单一指向；

02.设计模式的分类，可分为三大类：
1）创建型模式，共五种：
工厂模式、抽象工厂模式、建造者模式、单例模式、原型模式。

2）行为型模式，共十一种：
模板方法模式、策略模式、责任链模式、观察者模式、命令模式、访问者模式
状态模式、迭代子模式（数组迭代器）、备忘录模式、中介者模式、解释器模式

父类与子类：一个方法不同的实现，公共方法的提取形成的两种模式：策略模式、模板方法模式；适用于算法的改变。
两个类之间：观察者模式、迭代子模式(数组迭代器)、责任链模式（handler的循环链）、命令模式（相当于逐级传递）。
类的状态：备忘录模式（备份模式）、状态模式（状态的切换，卫星菜单栏）。
通过中间类：访问者模式、中介者模式、解释器模式。

3）结构型模式，共七种：
适配器模式、装饰器模式、代理模式、外观模式、
桥接模式、组合模式、享元模式

适配器模式：类（在MVP中用过，类似于两类重用一个方法）、对象（在一个类里的一个方法中调用另一个类里的相同方法）、接口（三种适配器模式）；
（后六种是对象适配器的衍生）：
装饰器模式（同接口间两个类的操作）-> 代理模式（与装饰器基本相同，细微差别具体分析）-> 外观模式（相当于类的组合排序）；
桥接模式（公共管理器，动态替换其中的对象）-> 组合模式（地址选择中有运用，有点类似于linked）-> 享元模式（一般结合工厂模式，jdbc连接池）。

4）其实还有两类：并发型模式和线程池模式。


第二章 创建型设计模式：五种
01.工厂模式：Factory Pattern
解释：应用最广泛的模式，一般模式：分为三块
模式：
1）产品接口，多个实现类，
2）工厂接口，对应实现类的多个工厂实现类
3）调用对应的工厂。

02.工厂模式由于有过多的工厂接口类，所以对于简单的应用还是直接使用静态工厂最好，复杂的就用抽象工厂模式。
简单（静态）工厂模式就是只有一个工厂的模式：多个产品接口，多个实现类，只在一个工厂内实现，调用。

接口类：
Iterable接口等等

03.抽象工厂模式：Abstract Factory Pattern
模式：
1）多个产品接口，产品实现类，
2）组合工厂接口，实现类工厂，
3）调用。

接口类：
1）MediaPlayer的创建

04.静态工厂与抽象工厂的对比：
1）静态工厂模式是一种极端情况的抽象工厂模式，而抽象工厂模式可以看成是工厂模式的推广。
2）静态工厂模式用来创建一个产品的等级结构，而抽象工厂模式是用来创建多个产品的等级结构。
3）静态工厂模式只有一个抽象产品类，而抽象工厂模式有多个抽象产品类。

05.建造者模式 Builder：
模式：
产品类 -> builder接口，对应的实现类 -> director
1）dialog的创建
2）WindowManager

06.单例模式:singleton
解释：应用最广的模式，几种模式实现方式：在反序列化时不会重新创建对象。
1）饿汉模式：第一次加载时就初始化，所以肯定是线程安全的，系统内使用的就是这种，所以也推荐使用。
2）懒汉模式（synchronized修饰方法）：第一次使用时才初始化，但是每次使用时，必须同步，一样会造成资源的浪费
3）双重检索模式：jdk中乱序，DCL失效，所以需要配合volatile使用，不过已不推荐使用，
4）静态内部类模式：即实现了线程安全，又避免了同步带来的性能影响，推荐使用的
也叫 懒汉式——延迟初始化占位类模式，通过类加载机制保证了线程安全，也能达到节省资源开销的目的。
5）枚举模式：线程安全，反序列化不生成新实例。推荐使用
6）单例容器：使用一个 HashMap 把单例类保存起来，通过特定的key来获取，getSystemService(系统服务)获取就是单例容器的应用
7）LayoutInflater

07.原型模式
解释：浅复制与深复制，当对象中的属性都为八种基本类型时，浅复制即可；其他引用类型需用深复制才能拷贝一份独立的对象。
1）Intent，Array的clone
2）由于clone()方法是protected修饰的，因此自定义model需要实现Cloneable接口，同时需要覆写clone()方法才能调用。


第三章 行为型设计模式：十一种，掌握六种
01.模板方法模式
在一条龙的服务中，有些服务是不确定的，这些服务就需要一个通用模板接口，根据实际需求去实现。

02.策略模式
解释：一种产品的多种实现，根据不同的需求选择对应的实现。（多态）（OCP与DIP原则）
1）动画的实现应用了策略模式
2）自定义的日历选择使用了策略模式。

03.模板方法模式与策略模式有什么区别？
模板方法模式是方法在不同步骤时的某一步分出来的多种变化，这时需要一个抽象方法，有子类去具体实现。
策略模式是对一个类的细化，提供不同的策略。

其实还是没啥具体的区别。

04.责任链模式：Iterator Pattern
解释：一个事件，依次逐级传递，最后被某一级对象所处理，则为纯责任链，如最终都没有处理，则为不纯。
如果说策略模式是单个选项的话，那责任链就是多选，其中每一级都含有对下一级的引用。
1）触摸事件的分发
2）handler
3）用广播也可以实现责任链模式。

05.观察者模式
是对对象的解耦；
专业解释：一个对象改变，所有依赖于他的对象都会得到通知。类似于责任链的串行（线性）传递，转成并行传递，相当于一个是串行，一个是并行。

可以这么理解：
观察者（observer）告诉被观察者（observed），我在关注你，你有改变了，记得通知我；
被观察者（observed）改变了，就会逐个通知关注他的观察者（observer）。

所以被观察者持有观察者的引用。

1）adapter适配器
2）BroadcastReceiver
3）事件总线

06.命令模式
解释：最大的作用就是用于解耦，主要用于多变的业务，把展示框中多变的业务分割出去。
通俗点说就是在展示框与多个实际业务的解耦，模式是：
展示框 -> 业务接口 -> 多个调用实际业务的类 -> 实际业务逻辑
1）android的输入事件

07.访问者模式
1.集合中不同的对象，通过方法重载，无法识别它们的具体类型。
2.通过双重委派机制，可以实现遍历识别，达成目标。

通俗点讲就是：
在一个有共同父类的多种类型的集合里，直接把 item 传递给使用它的对象，这个 item 是作为父类传递过去的，无法调用他自身的方法，未解决此问题，需利用双重分派机制，这弥补了多态的不足。

例子：
other.set(item)  // 这样是不行的。

必须这么着：
item.set(other)
然后再自身的类中实现
public void set(other){
other.set(this)
}
这样传给other的就是他自身，而不是它的父类了。

08.状态模式
解释：此模式模式和策略模式基本相同，但应用场景不同，适用于状态改变后，之后的操作都不一样。
1）WiFi的模式
2）登录的状态改变

09.解释器模式（懵逼中）
解释：Interpreter Pattern，使用较少，（目前我对此比较懵逼）。
1）计算器可以使用解释器来写

10.备忘录模式：Originator
解释：（被保存的对象）创建备忘录Memoto；Memoto需要存取的属性值，Caretaker保存和读取Memoto。
1）activity被杀死时备份
2）游戏存档

11.迭代器模式：Iterator，也叫游标模式Cursor。
1）Iterator迭代器，iterator与iterable联合使用
2）数据库中的游标

12.中介者模式
1）
2）
3）

第四章 结构型设计模式：七种，掌握六种
01.适配器模式
把AC两个类通过一个适配类B连接起来，让A可以使用C。
现有功能A -> 适配器B -> 现有实现C

02.桥接模式
把不同的功能串联起来起来
A -> B(A) -> C(B)  ....

适配器模式是为了把已有的功能组合起来使用。
桥接模式是把现有的系列顺序的串联起来。

03.装饰器模式
对现有的功能实现类进行二次包装
现有的接口 -> 现有的实现类 -> 继承接口的抽象包装类，并持有接口的实例 —> 实现的包装类

包装类因为是继承的接口，所以也可以互相包含。

04.代理模式：
还分为静态代理与动态代理

静态代理是 接口 -> 实现类 -> 继承接口的代理类（内含接口实例，转具体实现） -> 调用代理类。

多个接口的话，就会对应多个代理类，造成重复代码，这时候使用的就是动态代理，也就是靠反射来动态生成代理类，所以速度肯定比静态要慢

05.组合模式：其实就是树形结构，多级联动
其中节点 Node 内含 name childs 增删改查设置获取

06.外观模式：
把多个服务中需要向外部暴露的方法，组合成一个类，供外部调用。
举例来说：就是把ABC中需要用户调用的method，通过一个D类集中起来调用。

07.享元模式


